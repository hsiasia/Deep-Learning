# -*- coding: utf-8 -*-
"""RNN(StockPredict).ipynb」的副本

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C2bJqOM4i2ana5f_YduMTUk1OK-XqbeZ

![](https://i.imgur.com/3twMqGw.png)

# RNN : 股票預測

## **挑選一家公司來做預測**

資料集: [鉅亨網](https://www.cnyes.com/)

> **資料集說明**

別人恐懼我貪婪，一張不賣奇蹟來。
"""

import os

if(os.path.isfile("./train.csv") == False):
  !wget -O train.csv "http://140.115.82.54/NN/Recurrent/train.csv"
  !wget -O test.csv "http://140.115.82.54/NN/Recurrent/test.csv"

"""## 1. 讀入Package"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os
import random
import datetime
from sklearn.preprocessing import MinMaxScaler

"""## 2. 取得資料集"""

train_df = pd.read_csv("./train.csv")
train_df = train_df[::-1]
print("company : ",train_df["company"].unique())
train_df.head()

test_df = pd.read_csv("./test.csv")
test_df = test_df[::-1]
print("test data shape : ",test_df.shape)
test_df.head()

####################################
# 自己決定三家公司哪家公司(填數字)
# 挑選一家公司來做訓練、預測
####################################
companys = {"2330":"TSMC","2454":"MEDIATEK","2317":"FOXCONN"}
company_id = 2330

company = train_df[train_df["company"] == company_id]
company.index = company["date"]
company.head()

def include_last_iter(start,end,step):
  i = start
  while i < end:
      yield i
      i += step
  yield end-1

plt.figure(figsize=(16, 8))
plt.subplots_adjust(hspace=0.5)
for index,c in enumerate(companys):
  plt.subplot(2,2,index+1)
  company_df = train_df[train_df["company"] == int(c)]
  plt.plot(company_df["date"],company_df["price"])
  plt.xticks(list(include_last_iter(0,company_df.shape[0],250)),rotation=30)
  plt.title(companys[c])
  plt.xlabel("Date")
  plt.ylabel("price")
    
plt.show()

"""## 3. 資料前處理"""

# 切分training data & validation data
total_len = company.shape[0]
training_len = 2100
validation_data = total_len - training_len

print("總共有 : ",total_len,"筆")
print("訓練用 : (前)",training_len,"筆")
print("驗證用 : (後)",validation_data,"筆")

# MinMax Transformer 前處理
class MinMaxTransformer:
  def __init__(self):
    self.min = None
    self.max = None
    self.distance = None

  def fit(self,data):
    self.min = min(data)
    self.max = max(data)
    self.distance = self.max - self.min
    out = [(d-self.min)/self.distance for d in data]
    return out

  def recover(self,data):
    out = [d*self.distance+self.min for d in data]
    return out

  def transform(self,data):
    out = [(d-self.min)/self.distance for d in data]
    return out

  def transform_one(self,data):
    return (data-self.min)/self.distance

train_prices = company["price"].values

scalar = MinMaxTransformer()
scalar_data = scalar.fit(train_prices)

# 正規化
print("origin data : ",train_prices[:5])
print("transform data : ",scalar_data[:5])
print("recover data : ",scalar.recover(scalar_data[:5]))

# 切分資料集
training_data = scalar_data[:training_len]
validation_data = scalar_data[training_len:]

# 決定Seq長度
seq_len = 20

def split_input_target(seq):
  input_txt = tf.expand_dims(seq[:-1],-1)
  target_txt = tf.expand_dims(seq[1:],-1)
  return input_txt,target_txt

def make_ds(data):
  data_slice = tf.data.Dataset.from_tensor_slices(data)
  data_sequence = data_slice.batch(seq_len+1,drop_remainder=True)
  
  dataset = data_sequence.map(split_input_target)
  return dataset

# 製作資料集
train_ds = make_ds(training_data)
val_ds = make_ds(validation_data)

for input_example,target_exaple in train_ds.take(1):
  print("Input :", scalar.recover(input_example.numpy()))
  print("Target:", scalar.recover(target_exaple.numpy()))
  print("-"*50)
  print("Input :", input_example.numpy())
  print("Target:", target_exaple.numpy())

# Batch size
BATCH_SIZE = 5

BUFFER_SIZE = training_len

train_ds = (train_ds.shuffle(BUFFER_SIZE).batch(BATCH_SIZE))
val_ds = val_ds.batch(BATCH_SIZE)

train_ds
val_ds

"""## 4. 建立模型

提示: Output是一個數值，所以Model output維度為1。

* 輸入維度應為: (batch,seq_len,1)

* 輸出維度應為: (batch,seq_len,1)

**最後一層Dense不要加上任何activation function。**

"""

input_shape = (50,20,1)

model = tf.keras.Sequential()

model.add(
  tf.keras.layers.LSTM(
    units=128, 
    return_sequences=True, 
    input_shape=(20,1)))

model.add(
  tf.keras.layers.Dense(
      units=1))

model.summary()

"""## 5. 制定訓練計畫並訓練

我們做數字相關預測，可以考慮用Mean_Squared_Error

公式:
$$MSE = \frac{1}{n} \sum_{i=1}^N({\gamma-\hat{\gamma}})^2$$


提示:
不用管公式在幹嘛，compile帶入mean_squared_error。
"""

epochs = 20

model.compile(loss="mean_squared_error",optimizer="adam")

history = model.fit(
     train_ds, # 前面使用 tf.data 建構的資料集
     epochs=epochs,
     validation_data=val_ds
)

"""## 6. 評估模型"""

l1, = plt.plot(history.history['loss'])
l2, = plt.plot(history.history['val_loss'])
plt.legend(handles=[l1,l2],labels=['loss','val_loss'],loc='best')
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')

plt.show()

test_company = test_df[test_df["company"] == company_id]
test_company.head()

"""## 7. 做預測 (20分)"""

# 預測 Test data
# 現在我們取出了選定公司最後seq_len天
# 我們模型透過讀取seq_len天後預測出seq_len+1天的價格

# 將日期保存在datas中 (list)
# 將真實價格保存在real_prices中 (list)
# 將預測價格保存在pred_prices中 (list) *注: 請填入經過正規化後的價格

# input是一個經過**正規化**的真實價格list，請試著遍歷test_company來填滿上述三個list
# 可以TextGeneration的generateWords function，概念一樣，但是這次input請全部都填入"真實價格"

init_price = company.iloc[-seq_len:,:]["price"].values
dates = []
real_prices = []
pred_prices = []
input = scalar.transform(init_price)

for index,row in test_company.iterrows():
  # real_price和date放入list
  real_price = row["price"]
  real_prices.append(real_price)

  date = row["date"]
  dates.append(date)


  # 參考步驟 (在for迴圈中) :
  # 1. 把input轉**維度**成一個新變數next_input丟入model
  # 2. 獲得的pred取出seq中最後一個時間點的output數值 (提示: [0,-1,0])
  # 3. 把pred丟入pred_prices中
  # 4. 把real_price經過transform_one轉換成小數點並加在input後面
  # 5. 保持input長度為seq_len長 (也就是把最前面的數字踢掉)
  next_input = tf.expand_dims(input,axis=1)
  next_input = tf.expand_dims(next_input,axis=0)

  predicts = model(next_input)

  predicts = predicts[:,-1]

  chinese_ind = tf.squeeze(predicts).numpy()

  pred_prices.append(chinese_ind)

  real_price = scalar.transform_one(real_price)
  input.append(real_price)

print(f"dates : {dates[:10]}")
print(f"real_prices : {real_prices[:10]}")
print(f"pred_prices : {pred_prices[:10]}")

plt.figure(figsize=(16, 8))
l1, = plt.plot(dates,real_prices)
l2, = plt.plot(dates,scalar.recover(pred_prices))
plt.xticks(list(include_last_iter(0,len(dates),3)),rotation=30)
plt.legend(handles=[l1,l2],labels=['Real','Pred'],loc='best')
plt.title(companys[str(company_id)])
plt.xlabel("Date")
plt.ylabel("price")
plt.show()